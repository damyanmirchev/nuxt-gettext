import Vue from 'vue'

const SPACING_RE = /\s{2,}/g
const EVALUATION_RE = /[[\].]{1,2}/g
const INTERPOLATION_RE = /%\{((?:.|\n)+?)\}/g
const INTERPOLATION_PREFIX = '%{'

export default {
    SPACING_RE,
    EVALUATION_RE,
    INTERPOLATION_RE,
    INTERPOLATION_PREFIX,

    translations: {},
    /*
     * Get the translated string from the translation.json file generated by easygettext.
     *
     * @param {String} msgid - The translation key
     * @param {Number} n - The number to switch between singular and plural
     * @param {String} context - The translation key context
     * @param {String} defaultPlural - The default plural value (optional)
     * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')
     *
     * @return {String} The translated string
    */
    getTranslation (language, msgid, n = 1, context = null, defaultPlural = null) {
        if (!msgid) {
            return '' // Allow empty strings.
        }

        // const translations = {}

        // let silent = _Vue.config.getTextPluginSilent || (_Vue.config.getTextPluginMuteLanguages.indexOf(language) !== -1)

        // Default untranslated string, singular or plural.
        const untranslated = defaultPlural && this.getPluralIndex(language, n) > 0 ? defaultPlural : msgid

        // `easygettext`'s `gettext-compile` generates a JSON version of a .po file based on its `Language` field.
        // But in this field, `ll_CC` combinations denoting a language’s main dialect are abbreviated as `ll`,
        // for example `de` is equivalent to `de_DE` (German as spoken in Germany).
        // See the `Language` section in https://www.gnu.org/software/gettext/manual/html_node/Header-Entry.html
        // So try `ll_CC` first, or the `ll` abbreviation which can be three-letter sometimes:
        // https://www.gnu.org/software/gettext/manual/html_node/Language-Codes.html#Language-Codes
        const translations = this.translations[language] || this.translations[language.split('-')[0]]

        if (!translations) {
            console.warn(`No translations found for ${language}`)
            return untranslated
        }

        // Currently easygettext trims entries since it needs to output consistent PO translation content
        // even if a web template designer added spaces between lines (which are ignored in HTML or jade,
        // but are significant in text). See #65.
        // Replicate the same behaviour here.
        msgid = msgid.trim()

        let translated = translations[msgid]

        // Sometimes `msgid` may not have the same number of spaces than its translation key.
        // This could happen because we use the private attribute `_renderChildren` to access the raw uninterpolated
        // string to translate in the `created` hook of `component.js`: spaces are not exactly the same between the
        // HTML and the content of `_renderChildren`, e.g. 6 spaces becomes 4 etc. See #15, #38.
        // In such cases, we need to compare the translation keys and `msgid` with the same number of spaces.
        if (!translated && SPACING_RE.test(msgid)) {
            Object.keys(translations).some((key) => {
                if (key.replace(SPACING_RE, ' ') === msgid.replace(SPACING_RE, ' ')) {
                    translated = translations[key]
                    return translated
                }
            })
        }

        if (translated && context) {
            translated = translated[context]
        }

        if (!translated) {
            if (!Vue.config.silent) {
                let msg = `Untranslated ${language} key found: ${msgid}`
                if (context) {
                    msg += ` (with context: ${context})`
                }
                console.warn(msg)
            }
            return untranslated
        }

        // Avoid a crash when a msgid exists with and without a context, see #32.
        if (!(Array.isArray(translated)) && Object.prototype.hasOwnProperty.call(translated, '')) {
            // As things currently stand, the void key means a void context for easygettext.
            translated = translated['']
        }

        if (typeof translated === 'string') {
            translated = [translated]
        }

        let translationIndex = this.getPluralIndex(language, n)

        // Do not assume that the default value of n is 1 for the singular form of all languages.
        // E.g. Arabic, see #69.
        if (translated.length === 1 && n === 1) {
            translationIndex = 0
        }

        return translated[translationIndex]
    },

    /**
     * Evaluate a piece of template string containing %{ } placeholders.
     * E.g.: 'Hi %{ user.name }' => 'Hi Bob'
     *
     * This is a vm.$interpolate alternative for Vue 2.
     * https://vuejs.org/v2/guide/migration.html#vm-interpolate-removed
     *
     * @param {String} msgid - The translation key containing %{ } placeholders
     * @param {Object} context - An object whose elements are put in their corresponding placeholders
     * @param {Boolean} disableHtmlEscaping
     *
     * @return {String} The interpolated string
     */
    interpolate (msgid, context = {}, disableHtmlEscaping = false) {
        return msgid.replace(INTERPOLATION_RE, (match, token) => {
            const expression = token.trim()
            let evaluated

            const escapeHtmlMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                '\'': '&#039;'
            }

            // Avoid eval() by splitting `expression` and looping through its different properties if any, see #55.
            function getProps (obj, expression) {
                const arr = expression.split(EVALUATION_RE).filter(x => x)
                while (arr.length) {
                    obj = obj[arr.shift()]
                }
                return obj
            }

            function evalInContext (expression) {
                try {
                    evaluated = getProps(this, expression)
                } catch (e) {
                    // Ignore errors, because this function may be called recursively later.
                }
                if (evaluated === undefined) {
                    if (this.$parent) {
                        // Recursively climb the $parent chain to allow evaluation inside nested components, see #23 and #24.
                        return evalInContext.call(this.$parent, expression)
                    } else {
                        console.warn(`Cannot evaluate expression: ${expression}`)
                        evaluated = expression
                    }
                }
                const result = evaluated.toString()
                if (disableHtmlEscaping) {
                    // Do not escape HTML, see #78.
                    return result
                }
                // Escape HTML, see #78.
                return result.replace(/[&<>"']/g, function (m) {
                    return escapeHtmlMap[m]
                })
            }

            return evalInContext.call(context, expression)
        })
    },

    /**
     * @param {string} languageCode
     * @param {number} n
     * @returns {number}
     */
    getPluralIndex (languageCode, n) {
        n = Number(n)
        n = typeof n === 'number' && isNaN(n) ? 1 : n // Fallback to singular.

        // Extract the ISO 639 language code. The ISO 639 standard defines
        // two-letter codes for many languages, and three-letter codes for
        // more rarely used languages.
        // https://www.gnu.org/software/gettext/manual/html_node/Language-Codes.html#Language-Codes
        if (languageCode.length > 2 && languageCode !== 'pt-BR') {
            languageCode = languageCode.split('-')[0]
        }

        switch (languageCode) {
        case 'ay': // Aymará
        case 'bo': // Tibetan
        case 'cgg': // Chiga
        case 'dz': // Dzongkha
        case 'fa': // Persian
        case 'id': // Indonesian
        case 'ja': // Japanese
        case 'jbo': // Lojban
        case 'ka': // Georgian
        case 'kk': // Kazakh
        case 'km': // Khmer
        case 'ko': // Korean
        case 'ky': // Kyrgyz
        case 'lo': // Lao
        case 'ms': // Malay
        case 'my': // Burmese
        case 'sah': // Yakut
        case 'su': // Sundanese
        case 'th': // Thai
        case 'tt': // Tatar
        case 'ug': // Uyghur
        case 'vi': // Vietnamese
        case 'wo': // Wolof
        case 'zh': // Chinese
            // 1 form
            return 0
        case 'is': // Icelandic
            // 2 forms
            return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0
        case 'jv': // Javanese
            // 2 forms
            return n !== 0 ? 1 : 0
        case 'mk': // Macedonian
            // 2 forms
            return n === 1 || n % 10 === 1 ? 0 : 1
        case 'ach': // Acholi
        case 'ak': // Akan
        case 'am': // Amharic
        case 'arn': // Mapudungun
        case 'br': // Breton
        case 'fil': // Filipino
        case 'fr': // French
        case 'gun': // Gun
        case 'ln': // Lingala
        case 'mfe': // Mauritian Creole
        case 'mg': // Malagasy
        case 'mi': // Maori
        case 'oc': // Occitan
        case 'pt-BR': // Brazilian Portuguese
        case 'tg': // Tajik
        case 'ti': // Tigrinya
        case 'tr': // Turkish
        case 'uz': // Uzbek
        case 'wa': // Walloon
            /* eslint-disable */
            /* Disable "Duplicate case label" because there are 2 forms of Chinese plurals */
        case 'zh':  // Chinese
            /* eslint-enable */
            // 2 forms
            return n > 1 ? 1 : 0
        case 'lv': // Latvian
            // 3 forms
            return (n % 10 === 1 && n % 100 !== 11 ? 0 : n !== 0 ? 1 : 2)
        case 'lt': // Lithuanian
            // 3 forms
            return (n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2)
        case 'be': // Belarusian
        case 'bs': // Bosnian
        case 'hr': // Croatian
        case 'ru': // Russian
        case 'sr': // Serbian
        case 'uk': // Ukrainian
            // 3 forms
            return (
                n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2)
        case 'mnk': // Mandinka
            // 3 forms
            return (n === 0 ? 0 : n === 1 ? 1 : 2)
        case 'ro': // Romanian
            // 3 forms
            return (n === 1 ? 0 : (n === 0 || (n % 100 > 0 && n % 100 < 20)) ? 1 : 2)
        case 'pl': // Polish
            // 3 forms
            return (n === 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2)
        case 'cs': // Czech
        case 'sk': // Slovak
            // 3 forms
            return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2
        case 'csb': // Kashubian
            // 3 forms
            return (n === 1) ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2
        case 'sl': // Slovenian
            // 4 forms
            return (n % 100 === 1 ? 0 : n % 100 === 2 ? 1 : n % 100 === 3 || n % 100 === 4 ? 2 : 3)
        case 'mt': // Maltese
            // 4 forms
            return (n === 1 ? 0 : n === 0 || (n % 100 > 1 && n % 100 < 11) ? 1 : (n % 100 > 10 && n % 100 < 20) ? 2 : 3)
        case 'gd': // Scottish Gaelic
            // 4 forms
            return (n === 1 || n === 11) ? 0 : (n === 2 || n === 12) ? 1 : (n > 2 && n < 20) ? 2 : 3
        case 'cy': // Welsh
            // 4 forms
            return (n === 1) ? 0 : (n === 2) ? 1 : (n !== 8 && n !== 11) ? 2 : 3
        case 'kw': // Cornish
            // 4 forms
            return (n === 1) ? 0 : (n === 2) ? 1 : (n === 3) ? 2 : 3
        case 'ga': // Irish
            // 5 forms
            return n === 1 ? 0 : n === 2 ? 1 : (n > 2 && n < 7) ? 2 : (n > 6 && n < 11) ? 3 : 4
        case 'ar': // Arabic
            // 6 forms
            return (n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5)
        default: // Everything else
            return n !== 1 ? 1 : 0
        }
    }
}
